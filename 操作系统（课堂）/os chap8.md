# background

**内存管理的要求**：

* 重定位
* 保护：保护进程的地址空间不受侵犯
  * 必须在执行时检测
* 共享：
* 逻辑结构的组织

**stall**:失速

**内存管理单元**（MNU）：只能看到：

* 地址流和读请求
* 地址，数据和写请求

这里的地址是物理地址

**内存保护**：base寄存器和limit寄存器

首先解析指令，若解析出的地址小于base，则出错，否则，再判断是否小于base+limit之中存放的值，若小于，则加载到内存中，否则触发trap

## address binding

根据所使用的内存管理方案，进程在执行时可以在磁盘和内存间移动，在磁盘上等待调入内存的队列为input queue

绑定情况：

* compile time:如果在编译时就知道进程在内存中的驻留地址，那么可以生成有绝对地址的绝对代码，**如果起始地址改变必须重新编译**
* load time：如果编译时不知道，那么就必须生成可重定位代码，绑定会延迟到加载时才进行，如果起始地址发生变化，秩序重新加载用户代码
* executing time: 如果进程可以在内存段间移动，则必须到执行时再绑定，需要硬件支持，如（base,limit寄存器）

**使用前两种方法，从指令中解析出的地址都是物理地址，可以直接使用**

**逻辑地址**:CPU产生的，也称为virtual address

**物理地址**：MMU可见的地址

## MMU（Memory-Management Unit）

完成运行时从虚拟地址到物理地址映射的硬件设备

### 一个简单的MNU实现方案

![](.\chap8picture\QQ截图20211118103714.png)

重定位寄存器即base寄存器

用户只能看到逻辑地址

## 动态加载：

一个子程序只有在调用时才加载到内存，当需要该子程序，会调用relocatable linking loder

### 动态链接和共享库

动态链接将链接延迟到运行时，通常用于系统库，节省磁盘空间和内存空间

# Swapping

一个进程可以暂时从内存交换到backing store，之后需要再次执行时再调回内存

**Backing store**:快速磁盘

**Roll in,roll out**：用于基于优先级的调度算法

**ready queue**：包括在备份存储或在内存中准备运行的所有进程，保存了pcb

**dispatcher**:当调度程序决定执行进程时，使用调度程序检查队列中下用进程是否在内存中，如果不在内存中且没有空闲内存，将一个内存中的进程swap out，并swap in所需的进程

**每个进程的执行时间应该比交换时间长**

### 要求：

* 如果要换出进程，必须确保该进程完全处于空闲状态
* 如果要换出一个进程，而该进程正在等待I/O操作，如果I/O一部访问用户内存的I/O缓冲区，那么进程就不能被换出

#### 解决有I/O的进程交换

假设由于设备忙，I/O操作在排队等待，如果换出进程P1而换入P2，那么I/O操作可能会试图使用现在已经属于P2的内存

* 不能换出有待处理I/O的进程
* I/O操作的执行只能使用操作系统缓冲区，仅当换入进程后，才执行操作系统缓冲与进程内存之间的数据转移

**标准交换在现代os中不会使用**，因为交换需要花费很多时间

## overlay

当进程比可申请的内存大时需要覆盖

把程序分为若干个功能上相对独立的程序段，按照程序的逻辑结构让不会同时执行的程序段共享同一块内存区域

由用户来设计

不需要OS的额外支持

# Contiguous memory allocation（连续内存分配）

## 内存保护

![](.\chap8picture\QQ截图20211118110537.png)

MMU动态映射逻辑地址

分派程序加载limit,relocation寄存器

## 内存分配

**equal-size partitions**

**unequal-size**：给每个进程分配最小的可以运行进程的分区

**均会出现internal fragmentation**:被占用却没有使用的空间

需要的数据结构：

* Partition_id
* base address
* limit
* status

## variable-partition schema

**adjacent**：邻近的

动态划分（MVT）

**hole**：一块可用内存

**操作系统维持一个表，用于记录哪些内存可用，那些哪些内存被占用**

一开始，所有内存都可用于用户进程，因此可以作为一大块可用内存（即hole），当有新进程需要内存时，为该进程查找足够大的孔

随着进程进入系统，他们被装入输入队列，os根据所有进程的内存需要和现有的可用内存情况决定哪些进程可分配内存

当新进程需要内存时，系统为该进程查找足够大的hole，如果hole太大，就分为两块，一块给新进程，一块返回孔集合。当进程终止后，释放内存，释放的孔与临近的孔合并

#### 方法：

##### first fit

分配第一个足够大的hole

**回收**：按释放区的首地址查询空闲区表

* 若有与释放区相邻的空闲区，则合并到相邻的空闲区，并修改该区大小和首地址
* 否则，把释放区作为一个空闲区，将其大小和首地址按照首地址大小递增的顺序插入到空闲区表的适当位置

##### best fit

分配最小的足够大的hole

必须查找整个列表，按空闲区大小递增的次序组成空闲区表/队列

回收与first fit类似

**分配和回收后要重新排序**

##### worst fit

分配最大的hole

必须查找整个列表，按空闲区大小递减的顺序组织空闲区表

# Paging

分页内存管理方案允许进程的物理地址空间是非连续的，避免了将不同大小的内存块匹配到交换空间

## 基本方法

将物理内存分为固定大小的块，称为frame

讲逻辑内存分为同样大小的块，称为page

![](.\chap8picture\QQ截图20211122100443.png)

大小一般为2的整数次幂

由CPU生成的每个地址分为两个部分：页号（P）和页偏移（d），页表包含物理内存的基地址，基地址与页偏移的组合形成物理地址

![](.\chap8picture\QQ截图20211122100804.png)

![](.\chap8picture\QQ截图20211122101159.png)

**可以避免外部碎片，但可能有内部碎片**

**记录所有的空闲帧**

**最后一页会有内部碎片**

## 硬件支持

当页表比较小时（<256），使用一组寄存器来表示页表

当页表较长时，将页表放进内存，并将页表基寄存器（page-table base register，PTBR）指向页表，使用Page-table length register (PTLR)表示页表大小

**这种方法下每个数据需要申请两次内存分配**，一次是页表入口，一次是数据

可以用一种特殊的硬件cache解决，TLB

每个TLB由两部分组成：

* key
* value（page或者frame）

### translation look-aside buffers (TLBs)

![](.\chap8picture\QQ截图20211122105807.png)

若TLB已满，会使用LRU等策略替换

#### 有效访问时间

![](.\chap8picture\QQ截图20211122110437.png)

## 保护

通过与每个帧相关联的保护位实现内存保护

* rw位：只读或可读写
* valid-invalid位:
  * valid:表明这个页是当前进程的逻辑地址空间，是合法页
  * invalid：相反

## 共享页

共享代码必须有相同的逻辑地址和页

![](.\chap8picture\QQ截图20211122111137.png)

# 页表结构

## 层次结构

将页表再分页

![](.\chap8picture\QQ截图20211129104453.png)



## 哈希页表

通常在地址空间大于32位时使用

