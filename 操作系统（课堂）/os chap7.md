# 系统模型

进程使用资源顺序：

* 申请
* 使用
* 释放

* 永久性资源（物理资源）
  * 可剥夺资源（可重用资源），如内存
  * 不可剥夺资源：如打印机，死锁主要在共享这类资源时产生
* 临时性资源（逻辑资源）
  * 由一个进程产生，被另一个进程使用短暂一段时间后便无用的资源，竞争这些资源也可能产生死锁

# 死锁特征

## 必要特征

* 互斥
* 占有并等待，等待的资源为其他进程占有
* 非抢占：资源只能在进程完成任务后自动释放
* 循环等待

## 资源分配图

有限有向图：

* 进程指向资源的边表示已经申请并在等待(request edge)
* 资源指向进程的边表示已分配（assignment edge）

![](.\chap7picture\QQ截图20211108101856.png)

* 如果没有环，则没有死锁

# 处理方法

使四个必要特征不成立

## deadlock prevention

### hold and wait

必须保证当一个进程申请资源时，它不能占有其他资源：

* 一种协议是每个进程在执行前申请并获得所有资源
* 另一种协议允许进程在没有资源时才可申请资源

缺点：资源利用率较低，可能出现starvation

### not preemtive

如果一个进程占有资源并申请新资源在等待时，现有的资源可以被抢占

![](.\chap7picture\QQ截图20211108103257.png)

通常应用于状态可以保存和恢复的资源，如CPU，内存

### circular wait

对所有进程进行完全排序，要求每个进程按递增顺序来申请资源

## deadlock avoidance

### 安全状态

如果存在一个safe sequence，则处于安全状态

即如果系统能按某个顺序为每个进程分配资源并能避免死锁，那么就处于安全状态

#### 资源分配图算法

#### 银行家算法

当新进程进入系统时，它必须说明其可能需要的每种类型资源实例的最大数量。当用户申请资源时，系统必须确定这些资源的分配是否会使系统出于安全状态

数据结构：

![](.\chap7picture\QQ截图20211108110037.png)

##### 安全性算法

1. 设work和finish分别为长度为m和n的向量。work=available且对于i=0~n-1，finish[i]=false

2. 查找i满足

   ​	finsh[i]=false,need[i]<=work（false表明该进程还未检测，第二个语句表示需要的资源小于现在剩余的资源

   如果没有这样的i，则转到第四步

3. work=work+allocation[i], finish[i]=true(将已经分配的资源数加在现有的资源数上，表示该进程可以释放这么多资源)
4. 如果对所有i，finish[i]=true，那么出于安全状态

**该算法可以得到一个安全序列**

##### 资源请求算法

设*Request*为进程Pi的请求向量，如果*Request[j]=k*，则进程Pi需要Rj的数量是k，当进程Pi请求资源时;

1. 如果Request[i]<=Need[i]，转到2，否则产生出错条件，这是因为进程Pi以超过其最大请求
2. if Request[i]<=Available，转到3，否则等待，因为没有可用资源
3. Available=Available-Request[i],Allocation[i]=Allocation[i]+Request[i],Need[i]=Need[i]-Request[i]

