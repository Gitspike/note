# operating system  Structures
# operating-system services
## User interface(用户接口)
命令行界面（command- line interface）
批界面：通过将指令输入到文件中，执行文件来实现
图形用户界面（GUI）

## CLI
### command interpreter（命令解释程序）
有两种实施方式，放置在**内核**中（MS-DOS），或者在**系统程序**中（Windows/Linux）
在具有多个命令解释程序选择的系统中，解释程序被称为**shell**

#### 命令执行的两种方式
一种是CI本身包含执行命令的代码（MS-DOS）
一种是由系统程序实现绝大多数命令，只需要用命令来识别文件（UNIX），eg：
```shell
rm file.txt
```
CI会搜索名为rm的文件，将该文件装入内存，并用参数 file.txt执行
## GUI
User-friendly，nothing to say

# System Calls（系统调用）

操作系统提供的**编程接口**
例如：编写一个从一个文件复制数据到另一个文件的程序，会调用write，read等sys-calll（可以理解为系统用来实现这些功能的函数）
通常用高级语言来编写（C/C++）
大多数情况下程序会通过**API(Application Program Interface)**来调用sys-call而不是直接调用

## API
### 三种常见的API
* Windows api
* POSIX API，适用于POSIX系统（包括几乎所有UNIX，LINUX和Mac os X版本）
* JAVA  API，适用于运行在JVM上的程序
### Why API
* 程序便于移植，移植到不同平台时不用考虑系统调用的不同
* 系统调用比API更注重细节，也更难使用
### 向操作系统传参

* 通过寄存器传参
* 参数数量比寄存器多时，存在内存的块和表中，并将块的地址通过寄存器传递
* 参数也可通过程序放在或者压入堆栈，通过操作系统弹出
## 系统调用类型
### 进程控制
* 运行程序需要能正常地中断其执行（end）或不正常地中断（abort）
* 装入，执行（load，execute）
* 创建进程，终止进程（create，terminat）
* 取得进程属性，设置进程属性（get process attributes，set process attributes）
* 等待时间（wait for time ）
* 等待事件，唤醒事件（wait event，signal event）
* 申请和释放内存
* 当出错时转储内存，将程序和其工作空间夫人内容抄录到辅助内存（dump memory），并制成表
* 调试bug时单步执行程序
* 进程间共享数据时对访问管理加锁

#### dump（转储）

内存信息转储通常写到磁盘上，并被**调试器**检查和确定问题原因

不管中止是否正常，操作系统都必须将控制权转交给**命令解释器**

#### 控制卡（control card）

当出现一个错误时，有的系统允许其指出一个具体的恢复动作

是一个批处理概念，它是一个管理进程执行的命令，会给错误定义一个错误级别，命令解释器和下一个程序能通过错误级别来决定下一个动作。

### 文件管理

* create file,delete file
* read ,write,reposition(重定位)
* open,close
* get file attributes,set file attributes

### 设备管理

* request device,release device
* read ,write,reposition(重定位): 与文件非常相似，UNIX将两者合并为文件-设备结构，此时，一套系统调用可以同时用在文件和设备上
* logically attach or detach devices
* get device attributes,set device attributes

### 信息维护

### 通信

两种通信模型

#### 消息传递模型（message-passing model）

消息通过操作系统提供的interprocess-communication facility（进程间通信设施IPC）进行交换

在通信前，必须打开连接，知道另一个通信实体的名称，他可能是同一CPU的另一个进程，也可能是另一个计算机上的进程。每个进程有进程名（类似ip），它通常转换为标识符以便操作系统引用（使用get hostid和get processid这两个系统调用）

#### 共享内存模型（shared-memory model）

进程通过shared memory create和shared memory attach这两个sys-call来获得其他进程的内存区域的访问权

**注意**，通常情况下，操作系统会阻止一个进程访问另一个进程的内存，而共享内存会取消这个限制

# 系统程序

系统程序提供了一个方便的环境来开发或执行程序，可分为如下几类

## 文件管理

没啥说的

## 状态信息

* 一些程序从系统中获得日期，时间，可用内存，用户数的信息
* 还有一些提供更细节的内容，如详细的性能，调试信息
* 有些程序支持注册表(registy)，用于存储和检索配置信息

## 文件修改

## 程序语言支持

常用程序设计语言的编译程序，汇编程序，调试程序和解释程序

## 程序装入和执行

绝对加载程序，重定位加载程序，链接编辑器，覆盖式加载程序以及高级语言或机器语言的调试程序

## 通信

阿巴阿巴

## others

除系统程序外，操作系统提供程序来解决一般问题和执行一般操作，如网页浏览器，字处理器，文本格式化器，数据库系统，游戏等，这些程序被称为系统工具(system utilities)或应用程序(application programs)，由用户使用

## 后台服务

* 在开机时启动
* 在用户空间运行而不是内核
* 也被称为daemon(守护进程),subsystems(子系统)

# 操作系统的设计和实现

## 机制和策略

策略（policy）：做什么

机制（mechanism）：怎么做

eg：定时器结构是一种cpu保护机制，但是对于用户将定时器设置为多长时间是策略问题

策略和机制的区分对于灵活性很重要

## 实现

使用高级语言编写，更易2理解和调试，同时也更容易移植到不同平台

# 操作系统结构

## 简单模块

### MS-DOS   

* 利用最小的空间提供最多的功能，没有被划分为模块

* 没有很好区分接口和功能层次，例如应用程序可以访问基本的I/O子程序，直接写到磁盘驱动程序中
* 受限于inter 8088，未能提供双模式和硬件保护

### UNIX

由内核和系统程序组成，物理硬件之上和系统调用接口之下的所有部分作为内核，内核通过系统调用提供操作系统功能，总的来说，这一层组合类大量功能，这种单一式结构使得UNIX难以增强

## 分层方法(layered approach)

最底层（0）为硬件，最高层（N）为用户接口

* 好处
  * 调试，设计实现比较简单

### 困难：对层的详细定义

#### disk driver和memory-management routines

用于备份存储的设备驱动程序（虚存算法使用的磁盘空间）必须位于内存管理子程序之下，因为内存管理需要能使用磁盘空间

### disk driver和cpu scheduler

备份存储驱动程序通常在CPU调度器之上，因为该程序需要等待输入输出完成，并在这段时间内可以重新调度cpu

但是对于大型系统，CPU调度程序会有更多适合在内存中的活动进程的信息，这些信息需要换入换出内存，所以要求驱动程序在cpu调度器之下

### 其他问题

与其他方式相比效率较差

## 微内核

eg：Mach,Tru64 UNIX,QNX,

尽可能多的将非基本部分从内核中移走，并将其实现为系统程序或用户程序，只保留进程通信，内存管理和cpu调度

微内核主要功能为向用户程序和各种服务提供通信

### 优点

* 可扩展性
* 更灵活
* 可移植性
* 更安全可靠

### 缺点

由于系统功能总开销增加而导致系统性能下降

## 模块

许多现代操作系统使用可加载的内核模块，内核有一组核心组件以及在启动或运行时动态链接的附加服务，在现代的UNIX系统中很常见

使用面向对象的方法实现

比分层灵活，任意模块都能调用其他任何模块；比微内核高效，不需要消息传递来通信

## 混合结构

# 虚拟机

## 基本思想

单个计算机的硬件抽象为几个不同的执行部件，从而造成一种“幻觉”，仿佛每个独立的执行环境是在自己的计算机上运行一样

通过cpu调度和虚存技术，操作系统可以令进程认为自己有自己的处理器和自己的内存

## why  VM

根本原因是为了在并行运行几个不同的执行环境时可以共享相同的硬件

## 特点

* 虚拟机采用分层思想
* 虚拟机提供与其底层硬件相同的接口

## 优缺点
